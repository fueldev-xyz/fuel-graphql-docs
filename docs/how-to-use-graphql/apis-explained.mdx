---
title: 模式(Schema)和类型系统
category: How To Use GraphQL
---

# 模式(Schema)和类型系统

与传统的 REST API 不同，GraphQL 具有强大的类型系统来描述您的 API。GraphQL 模式描述了您可以使用 API 端点查询的数据，通过定义一组类型和映射到这些类型的字段。

跟着阅读，了解各种 GraphQL 类型。

## 对象类型

对象类型在 GraphQL 中描述了一个带有底层字段的对象，可以从您的 API 端点查询。

例如，对象类型可以定义如下所示：

```graphql
type actors {
  name: String!
  appearsIn: [movie!]!
}
```

在这里，`actors`是一个对象类型,而`name` 和 `appearsIn` 则是映射到 `actors`中的属性。

## 标量类型

> 来自 GraphQL 文档：

在上面对象类型的示例中，字段 `name` 的类型是 `String`。在 GraphQL 中，字符串默认是标量类型。这意味着它解析为一个确定的值，并且在查询时不能有进一步的子字段。标量类型表示查询的叶子。

GraphQL 自带一组默认的标量类型，如下所示：

- `Int`：有符号的 32 位整数。
- `Float`：有符号的双精度浮点数值。
- `String`：UTF-8 字符序列。
- `Boolean`：true 或 false。
- `ID`：ID 标量类型表示一个唯一的标识符，通常用于重新获取对象或作为缓存的键。ID 类型与字符串相同方式序列化；但是，将其定义为 ID 表示它不打算用于人类阅读。

字段也可以是默认情况下不是标量的类型，但在查询时解析为标量值。例如，在以下查询中，`name` 和 `appearsIn` 字段解析为标量类型。

```graphql
{
  hero {
    name
    appearsIn
  }
}
```

这是因为在模式中，`name` 和 `appearIn` 没有进一步可查询的子字段，如下所述：

```graphql
{
 "data": {
   "hero": {
     "name": "R2-D2",
     "appearsIn": [
       "NEWHOPE",
       "EMPIRE",
       "JEDI"
     ]
   }
 }
}
```

## 列表和非空值

> 来自 GraphQL 文档：

对象类型、标量和枚举是您可以在 GraphQL 中定义的唯一类型。但是，当您在模式的其他部分或查询变量声明中使用类型时，可以应用其他类型修饰符，影响这些值的验证。

让我们看一个示例：

```graphql
type Character {
  name: String!
  appearsIn: [Episode]!
}
```

在这里，我们使用了String类型，并通过在类型名称后添加感叹号`!`来将其标记为非空。这意味着我们的服务器始终期望返回此字段的非空值，如果最终获取到空值，则会触发GraphQL执行错误，通知客户端出现了问题。

非空类型修饰符还可用于为字段定义参数，导致GraphQL服务器在GraphQL字符串或变量中传递空值时返回验证错误。


```graphql
query DroidById($id: ID!) {
 droid(id: $id) {
   name
 }
}
{
 "id": null
}
```

```graphql
{
 "errors": [
   {
     "message": "Variable \"$id\" of non-null type \"ID!\" must not be null.",
     "locations": [
       {
         "line": 1,
         "column": 17
       }
     ]
   }
 ]
}
```

```graphql
myField: [String!]
```
这意味着列表本身可以为null，但它不能有任何null成员。例如，在JSON中：

```json
myField: null // 有效
myField: [] // 有效
myField: ['a', 'b'] // 有效
myField: ['a', null, 'b'] // 错误

```

## 联合类型

当查询返回一个联合类型时，您可以使用`... on`来指定特定返回类型的查询字段。这些也被称为内联片段。例如，下面的`hero`查询返回`Droid`或`Human`中的一个联合类型。

```graphql
query HeroForEpisode($ep: Episode!) {
  hero(episode: $ep) {
    name
    ... on Droid {
      primaryFunction
    }
    ... on Human {
      height
    }
  }
}
```

## 连接

当您期望多个结果并且可能需要分页时，连接是一种响应类型。每个以"Connection"结尾的查询返回类型都将包含以下返回字段：

```graphql
pageInfo: PageInfo!
edges: [SomethingEdge!]!
nodes: [Something!]!
```

### `PageInfo`

`pageInfo`返回一个对象，其中包含有关返回结果页面的信息：

`hasPreviousPage: Boolean!`
结果是否有前一页。

`hasNextPage: Boolean!`
结果是否有下一页。

`startCursor: String`
标识第一页的起始游标。

`endCursor: String`
标识最后一页的结束游标。

### 边缘

`edges`返回一个边缘对象数组，其中包含该页面的游标和第一个节点。您可以使用这些数据来帮助分页。

### 节点

`nodes`返回一个数组，其中包含您期望的分页结果的任何类型。

### 参数

这些查询还接受以下参数：
`first: Int`
`after: String`
`last: Int`
`before: String`

`first`和`last`都接受一个整数，用于设置每页返回的结果数。`first`将从开头分页结果，而`last`将从末尾开始。必须为`first`或`last`之一传递参数。如果未给出参数，则查询将不返回任何结果。

`after`和`before`都接受一个游标，您可以使用它来请求不同的页面。这两个都是可选参数。

您可以在这里的官方GraphQL文档中了解更多关于连接模型和分页的信息：[https://graphql.org/learn/pagination/](https://graphql.org/learn/pagination/)
